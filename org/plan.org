#+title: Twk Implementation Plan

* Overview

Twk is a Datastar integration library built on Sandestin. It provides feature parity with =datastar.wow= while embracing Sandestin's registry and dispatch system rather than owning those concepts.

** Core Philosophy

- Twk is "just another registry" in a Sandestin-powered application
- Users create their Sandestin dispatch with Twk's registry included
- The =with-datastar= middleware accepts an explicit dispatch function
- All Twk keys are namespaced to =ascolais.twk=
- Suggested alias: =twk=

* Dependencies

#+begin_src clojure
{:paths ["src/clj"]
 :deps  {io.github.brianium/sandestin {:git/tag "v0.1.0" :git/sha "cfe9c24"}
         dev.data-star.clojure/sdk    {:mvn/version "1.0.0-RC4"}
         dev.onionpancakes/chassis    {:mvn/version "1.0.365"}
         com.cnuernber/charred        {:mvn/version "1.037"}}
 :aliases
 {:dev  {:extra-paths ["dev/src/clj"]
         :extra-deps  {dev.data-star.clojure/brotli   {:mvn/version "1.0.0-RC4"}
                       dev.data-star.clojure/http-kit {:mvn/version "1.0.0-RC4"}
                       dev.data-star.clojure/ring     {:mvn/version "1.0.0-RC4"}
                       integrant/integrant            {:mvn/version "0.13.1"}
                       io.github.tonsky/clj-reload    {:mvn/version "0.9.7"}
                       metosin/malli                  {:mvn/version "0.19.1"}
                       metosin/reitit                 {:mvn/version "0.9.1"}
                       ring/ring-mock                 {:mvn/version "0.6.2"}}}
  :test {:extra-paths ["test/src/clj"]
         :extra-deps  {io.github.cognitect-labs/test-runner {:git/tag "v0.5.1" :git/sha "dfb30dd"}}
         :main-opts   ["-m" "cognitect.test-runner"]
         :exec-fn     cognitect.test-runner.api/test}}}
#+end_src

* Namespace Structure

| Namespace                | Purpose                                |
|--------------------------+----------------------------------------|
| =ascolais.twk=           | Main public API                        |
| =ascolais.twk.middleware= | Middleware implementation              |
| =ascolais.twk.schema=    | Malli schemas                          |
| =ascolais.twk.events=    | Hiccup-aware event wrappers (internal) |

* Main Exports (ascolais.twk)

** Registry (Function)

The registry is a function that accepts optional serializer overrides:

#+begin_src clojure
(defn registry
  "Returns a Sandestin registry providing Datastar effects and actions.
   Include this registry when creating your Sandestin dispatch.

   Options:
   | key          | description                                    |
   |--------------+------------------------------------------------|
   | :write-html  | HTML serializer. Defaults to chassis/html      |
   | :write-json  | JSON serializer. Defaults to charred/write-json-str |

   Expected system shape: {:sse <SSEGenerator> :request <ring-request>}

   Effects:
   - ::send          - Routes all actions through a single audit point
   - ::connection    - Returns existing connection from dispatch-data
   - ::close-sse     - Closes the SSE connection
   - ::sse-closed    - Dispatched on connection close (noop, for user extension)

   Actions:
   - ::patch-elements     - Patch a hiccup element
   - ::patch-elements-seq - Patch multiple hiccup elements
   - ::patch-signals      - Update client signals
   - ::execute-script     - Execute JavaScript

   system->state:
   - Extracts {:signals ...} from the request

   All effects and actions include Sandestin schema registrations for
   discoverability via (s/describe dispatch ::twk/patch-elements)"
  ([] (registry {}))
  ([{:keys [write-html write-json]}]
   {...}))
#+end_src

** Middleware

#+begin_src clojure
(defn with-datastar
  "Ring middleware for Datastar-powered applications.

   Arguments:
   - ->sse-response: SSE adapter from Datastar SDK (e.g., http-kit, jetty)
   - dispatch: A Sandestin dispatch function (required)
   - opts: Optional configuration map

   Options:
   | key                | description                                                    |
   |--------------------+----------------------------------------------------------------|
   | ::with-open-sse?   | Auto-close SSE after dispatch. Defaults to false               |
   | ::write-profile    | SSE write profile for all responses                            |
   | ::write-html       | HTML serializer for :body. Defaults to chassis/html            |
   | ::read-json        | JSON deserializer for signals. Defaults to charred             |
   | ::html-attrs       | Attributes injected into :body hiccup forms                    |

   System provided to dispatch:
   {:sse <SSEGenerator> :request <ring-request>}

   Dispatch-data provided:
   {::response <handler-response>
    ::request <ring-request>
    ::with-open-sse? <boolean>}"
  [->sse-response dispatch & [opts]]
  ...)
#+end_src

** SDK Re-exports (via def-clone)

Constants:
- =CDN-url=, =CDN-map-url=
- =id=, =retry-duration=, =selector=, =patch-mode=, =use-view-transition=
- =only-if-missing=, =auto-remove=, =attributes=
- =pm-outer=, =pm-inner=, =pm-remove=, =pm-prepend=, =pm-append=, =pm-before=, =pm-after=, =pm-replace=

Action helpers:
- =sse-get=, =sse-post=, =sse-put=, =sse-patch=, =sse-delete=

* Registry Implementation

** system->state

#+begin_src clojure
:ascolais.sandestin/system->state
(fn [{:keys [request]}]
  {:signals (:signals request)})
#+end_src

Note: Since =system->state= is "last wins" in Sandestin, users who need additional state should add a custom registry at the end that composes their state needs:

#+begin_src clojure
(def my-system->state-registry
  {:ascolais.sandestin/system->state
   (fn [{:keys [request]}]
     {:signals (:signals request)
      :user    (get-user-from-request request)})})

(s/create-dispatch [twk/registry my-registry my-system->state-registry])
#+end_src

** Effects

| Key            | Signature                               | Description                           |
|----------------+-----------------------------------------+---------------------------------------|
| =::send=       | =[ctx system action payload ?opts]=     | Central send effect (internal router) |
| =::connection= | =[ctx system]=                          | Returns connection from dispatch-data |
| =::close-sse=  | =[ctx system]=                          | Closes SSE connection                 |
| =::sse-closed= | =[ctx system]=                          | Noop hook for user extension          |

** Actions

| Key                  | Signature                | Returns                                 |
|----------------------+--------------------------+-----------------------------------------|
| =::patch-elements=     | =[state elements ?opts]= | =[[::send ::patch-elements ...]]=       |
| =::patch-elements-seq= | =[state els-seq ?opts]=  | =[[::send ::patch-elements-seq ...]]=   |
| =::patch-signals=      | =[state signals ?opts]=  | =[[::send ::patch-signals ...]]=        |
| =::execute-script=     | =[state script ?opts]=   | =[[::send ::execute-script ...]]=       |

** Schema Registrations

Each effect and action includes Malli schemas in the Sandestin registration format for discoverability:

#+begin_src clojure
{:ascolais.sandestin/effects
 {::send
  {:ascolais.sandestin/description "Route datastar events through a single send effect"
   :ascolais.sandestin/schema [:tuple :keyword :keyword :any [:? :map]]
   :ascolais.sandestin/handler (fn [ctx system & args] ...)}}}
#+end_src

Users can then use =(s/describe dispatch ::twk/patch-elements)= and =(s/sample dispatch ::twk/patch-elements)=.

* Middleware Implementation

** Composition

#+begin_src clojure
(comp
  (with-signals read-json)   ;; Parse signals onto request
  (with-html write-html attrs) ;; Render hiccup :body for non-Datastar
  (with-dispatch dispatch opts ->sse-response)) ;; Handle Datastar requests
#+end_src

** with-signals

- Checks =d*/datastar-request?=
- Parses signals via =d*/get-signals= and deserializes
- Adds =:signals= key to request

** with-html

- For non-Datastar requests with =:body= (hiccup)
- Renders to HTML with status 200 (or provided status)
- Injects =::html-attrs= if configured

** with-dispatch

- Checks for =::fx= key in response (also =:ðŸš€= alias)
- Creates SSE response via =->sse-response=
- Calls dispatch with system ={:sse sse :request request}=
- Handles existing connections (=::connection= key on response)
- Respects =::with-open-sse?= for auto-close behavior

* Schema (ascolais.twk.schema)

Schemas to port from datastar.wow:
- =Hiccup= - Recursive hiccup structure
- =Element= - Alias for Hiccup
- =Script= - String
- =Signals= - Map of keyword to any
- =PatchElementsOptions=, =PatchSignalsOptions=, =ExecuteScriptOptions=
- =DatastarAction= - Union of action tuples
- =DatastarResponse= - Response map with =::fx=
- =WithDatastarOpts= - Middleware options

* Key Differences from datastar.wow

| Aspect           | datastar.wow                          | Twk                                    |
|------------------+---------------------------------------+----------------------------------------|
| Registry         | Owns registry concept, accepts vector | Exports registry fn, user merges       |
| Dispatch         | Optional, can create internally       | Required, explicit parameter           |
| Namespace        | =datastar.wow/...=                    | =ascolais.twk/...=                     |
| Nexus            | Uses nexus.core                       | Uses ascolais.sandestin                |
| Registry merging | Internal with nexus aliases           | User handles via Sandestin             |
| Serializers      | Options on with-datastar              | Options on registry fn + with-datastar |

* Response Contract

Handlers return:

#+begin_src clojure
;; Non-Datastar: HTML response
{:body [:h1 "Hello"]}
{:body [:h1 "Error"] :status 404}

;; Datastar: Effect dispatch
{::twk/fx [[::twk/patch-elements [:h1#demo "Hello"]]
           [::twk/patch-signals {:count 1}]]}

;; With existing connection
{::twk/fx [[::twk/patch-elements [:h1 "Hi"]]]
 ::twk/connection existing-sse-gen}

;; Auto-close
{::twk/fx [[::twk/patch-elements [:h1 "Done"]]]
 ::twk/with-open-sse? true}

;; Fun enhancement
{:ðŸš€ [[::twk/patch-elements [:h1 "Rocket"]]]}
#+end_src

* Demo Application

A working demo mirroring datastar.wow's demo app. Located in =dev/src/clj/demo/=.

** Structure

| File            | Purpose                                           |
|-----------------+---------------------------------------------------|
| =demo/app.clj=    | Routes, handlers, hiccup components               |
| =demo/server.clj= | HTTP server adapters (http-kit)                   |
| =demo/system.clj= | Integrant system management                       |
| =demo/config.clj= | Integrant configuration                           |

** Demo Features

The demo is a simple CRUD-style user profile editor demonstrating:
- Server-rendered HTML (initial page load)
- SSE-based updates (edit, save, cancel, reset)
- Signal state management (form binding)
- Datastar attributes (=data-on:click=, =data-bind:=, =data-indicator:=)

** Key Differences from datastar.wow Demo

1. *Explicit dispatch creation*: Demo creates Sandestin dispatch with Twk registry
2. *Middleware takes dispatch*: =with-datastar= receives pre-configured dispatch
3. *Namespace references*: Uses =::twk/fx=, =::twk/patch-elements=, etc.

** Demo Setup Pattern

#+begin_src clojure
(ns demo.config
  (:require [ascolais.sandestin :as s]
            [ascolais.twk :as twk]
            [demo.app :as app]))

;; Create dispatch with Twk registry (and any user registries)
(def dispatch
  (s/create-dispatch [(twk/registry)]))

(def config
  {::app/with-datastar {:dispatch dispatch
                        :type     :httpkit}
   ::app/router        {:routes     app/routes
                        :middleware [(ig/ref ::app/with-datastar)]}
   ::app/handler       {:router (ig/ref ::app/router)}
   ::app/server        {:handler (ig/ref ::app/handler)}
   ::app/state         app/initial-state})
#+end_src

** Demo Handlers

#+begin_src clojure
(ns demo.app
  (:require [ascolais.twk :as twk]))

(defn index
  [{:keys [request-method signals]
    {{:keys [state]} :data} ::r/match}]
  (case request-method
    :get {:body (page @state)}
    :put {:ðŸš€ [[::twk/patch-elements [::user#demo (reset! state signals)]]]}))

(defn edit
  [{{{:keys [state]} :data} ::r/match}]
  {::twk/with-open-sse? true
   :ðŸš€ [[::twk/patch-elements [::user-form#demo @state]]]})

(defn cancel
  [{{{:keys [state]} :data} ::r/match}]
  {::twk/with-open-sse? true
   :ðŸš€ [[::twk/patch-elements [::user#demo @state]]
        [::twk/patch-signals @state]]})
#+end_src

* Test Plan

Mirror datastar.wow test coverage:

** HTML Response Tests
- Default 200 OK
- User-provided status
- User-provided headers
- HTML attribute injection
- Alternative write-html function

** Signal Tests
- Signal parsing and inclusion on request

** Effect Tests
- =::patch-elements= with and without options
- =::patch-elements-seq= with and without options
- =::patch-signals= with and without options
- =::execute-script= with and without options
- Multiple effects in sequence
- =::close-sse= effect
- Fun enhancement (ðŸš€ alias)

** Connection Tests
- Using existing connection
- Status and headers in SSE response

** with-open-sse Tests
- Configured in middleware
- Configured in response
- Ignored with existing connection

** Customization Tests
- Custom read-json
- Custom write-json
- Custom write-html
- Custom registry serializers

** Integration with User Effects
- User-defined effects work alongside Twk effects
- Pure actions receive signals as state
- Placeholders work
- Error capture via interceptors

* Implementation Order

1. [ ] Set up project dependencies (deps.edn)
2. [ ] Create =ascolais.twk.schema= with ported schemas
3. [ ] Create =ascolais.twk.events= (hiccup-aware wrappers)
4. [ ] Create =ascolais.twk.middleware= with:
   - [ ] =with-signals=
   - [ ] =with-html=
   - [ ] =with-dispatch=
5. [ ] Create =ascolais.twk= with:
   - [ ] =registry= function (effects, actions, system->state, schemas)
   - [ ] =with-datastar= middleware function
   - [ ] SDK re-exports via def-clone
6. [ ] Port test suite from datastar.wow
7. [ ] Create demo application:
   - [ ] =demo/server.clj=
   - [ ] =demo/system.clj=
   - [ ] =demo/config.clj=
   - [ ] =demo/app.clj=
8. [ ] Manual integration testing with demo

* Resolved Decisions

1. *Registry as function*: Yes - =(twk/registry {:write-html my-fn})= for serializer overrides

2. *Schema discoverability*: Yes - Full Sandestin schema registrations for =(s/describe)= and =(s/sample)=

3. *Fun enhancer*: Yes - Keep the ðŸš€ alias for =::fx=

4. *Suggested alias*: =twk= - e.g., =(require '[ascolais.twk :as twk])=

5. *Sandestin dependency*: Use git coordinates
   #+begin_src clojure
   {io.github.brianium/sandestin {:git/tag "v0.1.0" :git/sha "cfe9c24"}}
   #+end_src

